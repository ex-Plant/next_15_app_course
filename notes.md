**generate metadata**

export const metadata: Metadata = {
title: "Create Next App",
description: "Generated by create next app",
};

you can add it at the layout level and tha overwrite it on the page level if you want to have a dynamic title or
description

**Dynamic metadata**

- you have access to params in generateMetadata function
  `export const generateMetadata({params}): Metadata  {}`
- you can also fetch data in generateMetadata and use this data in there 🤔
- since there is a fetch request memoization we do not have to worry about refetching data in generateMetadata

- **mounting**
- adding component to the DOM
- unmounting is the opposite

UseEffect runs when the component mounts and unmounts or whenever the dependency changes

cleanup function runs on unmount so that we can get rid of all the effects running in the background - we don't want
them running when the component is not in the DOM anymore

Lets say we are doing something like setting an interval

_usePathname_

- from next/navigation
- use to get the current path

**types**

- file with common types can be added to lib/types

**@/import**
tsconfig.json
paths - default to src

this means @ will point to src catalogue
"paths": {
"@/_": ["./src/_"]
}

**Client-Side Cache**

- stores RSC payload after navigating to some page and going back - data for that page is already rendered and ready
- **loading**

- equivalent of suspense in react

**skeleton component**

- basically some divs with animate pulse

**Array.from({length: 6)}.map(() => {})**

\*_Fetching data on component level with suspense wrapper_

- avoid blocking the whole page when fetching data - you can show some parts of the UI not needing fetched data and
  only supsened components with dynamic data

**CACHING MEMOIZATION**

- memoization last for the duration of the render pass -
  "The cache lasts the lifetime of a server request until the React component tree has finished rendering."
  When a server receives a request to render a page, it may fetch data (e.g., with fetch()).
  React (and Next.js) will cache the results of these fetches for the duration of that single server request.
  This cache is only valid while the server is building the React component tree for that request.
  Once the rendering is done and the response is sent to the client, the cache is discarded.
  If a new request comes in, a new cache is created for that request.
  A user visits or reloads a page that is rendered on the server (SSR/Server Components).
  The client navigates to a new page that requires server-side rendering (e.g., via Next.js app router navigation).
  An API route or server function is called that triggers a new server-side render.
  If a site is static (using Static Site Generation, SSG, in Next.js or similar frameworks):

The page is rendered on the server only during build time (when you run next build or the equivalent build command).
The HTML (and any data fetched during build) is generated once, then saved as static files.
When a user visits the site, the server (or CDN) just serves these pre-built static files—no server-side rendering
happens at request time.
The fetch cache/memoization applies only during the build process, not at runtime.
Summary:
For static pages, server rendering (and fetch memoization) only happens at build time. All users get the same pre-rendered HTML until you rebuild the site.

Ok if the page is dynamic this server pass will happen on revalidation
Or if it is fully dynamic than it will happen every time user navigates to any page

You are correct!

If the page is dynamic with revalidation (using revalidate or ISR in Next.js):
The server render (server pass) happens:
At build time (for the initial static generation).
Again, whenever the revalidation interval expires and a new request comes in (the page is regenerated on the server and the cache is updated).
If the page is fully dynamic (e.g., dynamic = "force-dynamic" in Next.js):
The server render happens every time a user requests or navigates to that page.
There is no static cache; each request triggers a fresh server-side render and fetch.

- seed db

- useSearchParams for client components
- params, searchParams for async pages

**SUSPENSE**

- add key to make it work on the same route

**zod**

- zod is not used only to validate forms - it can be also very useful to check if data coming from db or any other
  data source is keeping the correct structure

**dynamic vs static**

- static - component run during the build - html is already there during the build it is not created on request
- dynamic - rerendered on request
- using some next.js features will automatically turn some pages into dynamic pages, for example using cookies,
  search params, params etc. since these features are client side features
- generate static params can make some of these dynamic pages static so that next.js can render them statically
  during the build
- generateStaticParams MUST return array of slug objects [{slug: "slug"}] - this way next js knows it needs to run
  them during build and render them -`CLIENT COMPONENTS RUN ON THE SERVER ONCE - during build time`

**PREFETCHING IN LINK COMPONENT**

- on prod - not on dev! - next will prefetch data to components, pages when they are in view.
- It will receive `REACT SERVER COMPONENT PAYLOAD` which is a result of rendering a server component and put it in the
  client-side cache (`ROUTER CACHE`)

**unstable_cache**
- if we are not using fetch that is cached by default we need to do that ourselves
- using unstable cache is caching data from data source for the duration a session - refresh will delete it


**server security and server-only**
- whenever there is some vulnerable users data that you do not want to leek to the client it is good idea to put them 
  to a separate catalogue like server-utils etc. 
- then you install a package called server-only and import it at the top of the file that you want to keep on the server
- if you try to call this function from within server component this should throw an error 


**openGraph**
- test if your page images shows up correctly on social media etc


**server actions**
- onSubmit - you can not do that in a server component!


**useOptimistic**
**useActionState**
const [state, formAction] = useActionState(createTicket, initState);

//
// useEffect(() => {
//   console.log(state, "state");
//   if (state.success) {
//     toast.success(`😎`);
//     router.push(`/tickets`);
//   }
//   console.log(state, `🍆`);
// }, [state]);


**useTransition**
const [isPending, startTransition] = useTransition();
const router = useRouter();

async function handleRegister(formData: FormData) {
startTransition(async () => {
const res = await registerUser(initState, formData);
console.log(res, "res");

      if (res.success === "ok") {
        toast.success(`User registered 🚀`);
        router.push(`/tickets`);
      }
      if (res.success === "failed") {
        toast.error(`Something went wrong 🚨:` + res.message);
      }
    });
}


*useFormAction*
- for actions outside forms like in buttons, stand alone inputs etc.
