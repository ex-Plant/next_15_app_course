**generate metadata**

export const metadata: Metadata = {
title: "Create Next App",
description: "Generated by create next app",
};

you can add it at the layout level and tha overwrite it on the page level if you want to have a dynamic title or
description

**Dynamic metadata**

- you have access to params in generateMetadata function
  `export const generateMetadata({params}): Metadata  {}`
- you can also fetch data in generateMetadata and use this data in there ðŸ¤”
- since there is a fetch request memoization we do not have to worry about refetching data in generateMetadata

- **mounting**
- adding component to the DOM
- unmounting is the opposite

UseEffect runs when the component mounts and unmounts or whenever the dependency changes

cleanup function runs on unmount so that we can get rid of all the effects running in the background - we don't want
them running when the component is not in the DOM anymore

Lets say we are doing something like setting an interval

_usePathname_

- from next/navigation
- use to get the current path

**types**

- file with common types can be added to lib/types

**@/import**
tsconfig.json
paths - default to src

this means @ will point to src catalogue
"paths": {
"@/*": ["./src/*"]
}

**flex-1**
flex-1
This is a utility (e.g., in Tailwind CSS) that applies:

css
CopyInsert
flex: 1 1 0%;
The element will grow to fill available space in a flex container.
It shares space equally with other items using flex-1.
basis-80
This sets the flex-basis property:

flex-basis: 20rem; /_ in Tailwind, 80 = 20rem = 320px _/
This defines the initial main size of a flex item before it grows or shrinks.
The item will start at 20rem wide (if horizontal flex) or tall (if vertical flex).
In summary:

flex-1 makes an item flexible and able to grow/shrink.
basis-80 sets its starting size to 20rem.
You can use both together to control both flexibility and initial size in layouts.

ok and flex 1 means grow true shrink true basis 0

**basis-80**
In Tailwind, 80 refers to a spacing scale value, where 80 equals 20rem (which is 320px).

flex-0
flex: 0 0 auto;

**fancy hover effect**

- active happens when you click an image as in the drag event or something like that

`hover:scale-110 active:scale-[1.02] transition overflow hidden `

**fancy image background **
blur original image , low quality
blur-3xl
sizes
(max-width: 1280px: 100vw, 1280px)

**Client-Side Cache**

- stores RSC payload after navigating to some page and going back - data for that page is already rendered and ready
-

**loading**

- equivalent of suspense in react

**skeleton component**
- basically some divs with animate pulse


**Array.from({length: 6)}.map(() => {})**

\*_Fetching data on component level with suspense wrapper_

- avoid blocking the whole page when fetching data - you can show some parts of the UI not needing fetched data and
  only supsened components with dynamic data

**CACHING MEMOIZATION**

- memoization last for the duration of the render pass -
  "The cache lasts the lifetime of a server request until the React component tree has finished rendering."
  When a server receives a request to render a page, it may fetch data (e.g., with fetch()).
  React (and Next.js) will cache the results of these fetches for the duration of that single server request.
  This cache is only valid while the server is building the React component tree for that request.
  Once the rendering is done and the response is sent to the client, the cache is discarded.
  If a new request comes in, a new cache is created for that request.
  A user visits or reloads a page that is rendered on the server (SSR/Server Components).
  The client navigates to a new page that requires server-side rendering (e.g., via Next.js app router navigation).
  An API route or server function is called that triggers a new server-side render.
  If a site is static (using Static Site Generation, SSG, in Next.js or similar frameworks):

The page is rendered on the server only during build time (when you run next build or the equivalent build command).
The HTML (and any data fetched during build) is generated once, then saved as static files.
When a user visits the site, the server (or CDN) just serves these pre-built static filesâ€”no server-side rendering happens at request time.
The fetch cache/memoization applies only during the build process, not at runtime.
Summary:
For static pages, server rendering (and fetch memoization) only happens at build time. All users get the same pre-rendered HTML until you rebuild the site.

Ok if the page is dynamic this server pass will happen on revalidation
Or if it is fully dynamic than it will happen every time user navigates to any page

You are correct!

If the page is dynamic with revalidation (using revalidate or ISR in Next.js):
The server render (server pass) happens:
At build time (for the initial static generation).
Again, whenever the revalidation interval expires and a new request comes in (the page is regenerated on the server and the cache is updated).
If the page is fully dynamic (e.g., dynamic = "force-dynamic" in Next.js):
The server render happens every time a user requests or navigates to that page.
There is no static cache; each request triggers a fresh server-side render and fetch.
